TODO
----

Code:
  - add support for Power
    - single-entities for Grid/Battery/Devices
    - no stats-gathering, just sensors
    - sensor types are now Power and Measurement
    - support State-of-Charge for Battery
    - see what else should be changed/hidden
  - unit-testing
  - move the language files to Typescript so enum values can be used for the keys
  - dynamic labelling for, eg, Battery's import ('discharge') and export ('charge') fields in the UI
  - Dashboard label:
    - split the URL on the /
    - the first segment can be found in this.hass.panels
    - if there is a second segment, this is a View:
      - make the API call to get the config for the first segment
      - find the View

Config:
  - is it possible to auto-detect changes to the Energy config?
    - if we do, how should this be handled?
      - can't just overwrite the user's config...
      - we'd need a flag which instructed the card to use the Energy config rather than its own
        - so this needs some thought - we shouldn't be duplicating the Energy config in the card
    - if not, we could have a button on the main page to (re)load the entities from that config

Display:
  - odd layout glitches when changing settings, refreshing the page, etc - the circles are small and squashed
  - if data is still loading when we render, go ahead and render the diagram anyway, just put 'loading' for the values (or an overlay in the centre of the card?)
    - related: also seeing the 'you are not configured' message
  - Flows:
    - in non-HASS mode, see if the grid->home flow can be made to alternate between high and low carbon colours on successive runs
      - ideally in proportion, but otherwise a simple 1:1 will do
      - can animation do this?
      - similarly, the grid-import ring can now show high and low
    - fix z-ordering so that dots appear on top of lines
      - will require re-ordering the svg elements, which changes the way we render
    - go back to specifying direction:
        - this will fix the alignment and overlap problems with the dashed line, and will help when doing bi-directional devices
  - Home:
    - include producing devices in the segment arrays
    - if 'subtract' is set, subtract consuming devices from the appropriate total
  - Devices:
    - see if the Energy Dashboard's devices can be detected and loaded
    - first attempt to expand to the right
    - if there is not enough space for the required number of columns, expand below instead
    - for rightwards, draw the bus out from the Home circle and position devices above/below it
      - could try to get clever and stop the bus one column from the end so we can fit three devices in a column
    - for downwards, draw the bus from the bottom of the Home circle, then turn left to the centre column and then downwards
      - this occpuies the first 'row' below the standard 3x3 grid (or 3x2 if no battery is present)
      - devices now go to the left/right of the bus
        - and again, the bottom-most row could contain three devices


Under consideration
-------------------

  - more modes:
    - current month
    - current year
    - perhaps a user-supplied date-range?
    - could display this as a title?
  - display the flow rates as hover-overs on the lines
    - or over the circles?
    - or do we bother?  the segments may be enough now
  - may be able to remove pruneConfig() now
    - but see if it can be used to filter out 'bad' config rather than forcing the user into YAML mode
      - or failing that - is there any way to find out from validation what the bad config is so we can at least *tell* the user?
        - looks like it - see superstruct
  - see if the 'state' values in the State objects can be made internal/private - they should not be accessed outside the EntityStates object
    - probably not, they'd have to be instance fields on EntityStates
  - alternative flow algorithm which prioritises House->Battery->Grid
    - implementation:
      - define consts/enum for the four nodes: House, Grid, Battery, Solar
      - define arrays of 'producer order' and 'consumer order': these use the consts
      - inside the flow-calculation:
        - use the five supplied values plus the calculated 'to house' value to populate an array of nodes, where each entry is a tuple{producer,consumer} using 'undefined' where appropriate
        - iterate over the selected 'producer order' array
          - for each producer, iterate over the 'consumer order' array, skipping where producer==consumer
          - calculate the producer->consumer flow value at this point and increment the corresponding entry in a 2d-array, where the first index is the 'producer' and the second the 'consumer'
        - finally, pull the values out of the 2d-array and populate the Flows object as normal
      - check whether this actually matches how the HASS algo works!
        - might, for example, need per-producer 'consumer order' arrays rather than a single one
      - the arrays are selected based on the config, eg:
        - for HASS the 'producer' might be [Solar,Battery,Grid] and 'consumer' [Battery,Grid,House]
        - whereas for a more realistic approach the 'consumer' would be [House,Battery,Grid]
        - we can give the user some degree of control here if/as required, but the basic algo should cope with any setup



Before release
--------------

  - rename to 'Energy Distribution Extended' (energy-distribution-ext) for consistency with the built-in card
    - or something else, given Power support as well
  - README and CHANGELOG updates
  - add license
  - reinstate terser in rollup.config.js
  - test localisation by disabling EN and checking that all strings revert to their keys
    - also check that there aren't any redundant keys!
      - if all keys are enums, this should be simple
  - find out why there seems to be a serious delay in populating the display after setting the date or changing the config
    - apparently receiving each data-set (primary and secondary) twice per card
